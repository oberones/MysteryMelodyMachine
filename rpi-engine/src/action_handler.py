"""Event handlers for semantic actions.

Translates semantic events from the router into state changes and sequencer operations.
Phase 2: Basic parameter mapping and step triggering.
Phase 6: Idle mode interaction tracking.
Phase 7: External hardware CC profile parameter integration.
"""

from __future__ import annotations
from typing import Dict, Callable, Optional, TYPE_CHECKING
import logging
from state import State
from sequencer import Sequencer, NoteEvent
from events import SemanticEvent
from note_utils import format_note_with_number

if TYPE_CHECKING:
    from idle import IdleManager
    try:
        from .external_hardware import ExternalHardwareManager
    except ImportError:
        from external_hardware import ExternalHardwareManager

log = logging.getLogger(__name__)


class ActionHandler:
    """Handles semantic actions by updating state and triggering sequencer operations."""
    
    def __init__(self, state: State, sequencer: Optional[Sequencer] = None):
        self.state = state
        self.sequencer = sequencer
        self._note_callback: Optional[Callable[[NoteEvent], None]] = None
        self._idle_manager: Optional[IdleManager] = None
        self._external_hardware: Optional[ExternalHardwareManager] = None  # Phase 7
        
        # Mapping from semantic action types to handler methods
        self._action_handlers: Dict[str, Callable[[SemanticEvent], None]] = {
            'trigger_step': self._handle_trigger_step,
            'tempo': self._handle_tempo,
            'filter_cutoff': self._handle_filter_cutoff,
            'filter_resonance': self._handle_filter_resonance,
            'eg_attack': self._handle_eg_attack,
            'eg_release': self._handle_eg_release,
            'reverb_mix': self._handle_reverb_mix,
            'delay_mix': self._handle_delay_mix,
            'osc_a': self._handle_osc_a,
            'osc_b': self._handle_osc_b,
            'mod_a': self._handle_mod_a,
            'mod_b': self._handle_mod_b,
            'osc_type': self._handle_osc_type,
            'filter_type': self._handle_filter_type,
            'mod_type': self._handle_mod_type,
            'swing': self._handle_swing,
            'density': self._handle_density,
            'gate_length': self._handle_gate_length,
            'note_probability': self._handle_note_probability,
            'master_volume': self._handle_master_volume,
            'sequence_length': self._handle_sequence_length,
            'scale_select': self._handle_scale_select,
            'chaos_lock': self._handle_chaos_lock,
            'reserved': self._handle_reserved,
            'mode': self._handle_mode,
            'palette': self._handle_palette,
            'drift': self._handle_drift,
        }
    
    def set_sequencer(self, sequencer: Sequencer):
        """Set the sequencer instance (for late binding)."""
        self.sequencer = sequencer
    
    def set_note_callback(self, callback: Callable[[NoteEvent], None]):
        """Set callback for note events generated by manual triggers."""
        self._note_callback = callback
    
    def set_idle_manager(self, idle_manager: IdleManager):
        """Set the idle manager instance (for interaction tracking)."""
        self._idle_manager = idle_manager
    
    def set_external_hardware(self, external_hardware: ExternalHardwareManager):
        """Set the external hardware manager instance (Phase 7)."""
        self._external_hardware = external_hardware
    
    def handle_semantic_event(self, event: SemanticEvent):
        """Route a semantic event to the appropriate handler."""
        # Determine if this is a tempo-related interaction
        preserve_tempo = event.type == 'tempo'
        
        # Notify idle manager of interaction
        if self._idle_manager:
            self._idle_manager.touch(preserve_tempo=preserve_tempo)
        
        handler = self._action_handlers.get(event.type)
        if handler:
            try:
                handler(event)
                log.debug(f"action_handled type={event.type} value={event.value}")
            except Exception as e:
                log.error(f"Action handler error for {event.type}: {e}")
        else:
            log.warning(f"Unknown semantic action: {event.type}")
    
    def _handle_trigger_step(self, event: SemanticEvent):
        """Handle step trigger from button press.
        
        Phase 2: Manual step triggering - advance sequencer by one step.
        """
        if self.sequencer:
            # Force advance to next step
            current_step = self.state.get('step_position', 0)
            sequence_length = self.state.get('sequence_length', 8)
            next_step = (current_step + 1) % sequence_length
            self.state.set('step_position', next_step, source='manual_trigger')
            
            # Generate immediate note for manual trigger
            # Use note value from button press as basis
            if event.raw_note is not None and self._note_callback:
                # Simple mapping: use the button note directly with some velocity
                note = event.raw_note
                velocity = min(127, max(60, event.value or 80))
                
                note_event = NoteEvent(
                    note=note,
                    velocity=velocity,
                    timestamp=0.0,  # Will be set by callback handler
                    step=current_step
                )
                self._note_callback(note_event)
                note_info = format_note_with_number(note)
                log.info(f"manual_trigger step={current_step} note={note_info} velocity={velocity}")
    
    def _handle_tempo(self, event: SemanticEvent):
        """Handle tempo change (CC 20)."""
        if event.value is not None:
            # Map CC value (0-127) to BPM range (60-200)
            bpm = 60.0 + (event.value / 127.0) * 140.0
            self.state.set('bpm', bpm, source='midi')
    
    def _handle_filter_cutoff(self, event: SemanticEvent):
        """Handle filter cutoff change (CC 2 -> NTS-1 CC 43)."""
        if event.value is not None:
            # Store in state for internal use
            self.state.set('filter_cutoff', event.value, source='midi')
            
            # Phase 7: Send to external hardware via CC profile
            if self._external_hardware:
                # Map CC value (0-127) to 0.0-1.0 for CC profile
                normalized_value = event.value / 127.0
                self._external_hardware.send_parameter_change('filter_cutoff', normalized_value)
    
    def _handle_filter_resonance(self, event: SemanticEvent):
        """Handle filter resonance change (CC 22 -> NTS-1 CC 44)."""
        if event.value is not None:
            # Store in state for internal use  
            self.state.set('filter_resonance', event.value, source='midi')
            
            # Phase 7: Send to external hardware via CC profile
            if self._external_hardware:
                normalized_value = event.value / 127.0
                self._external_hardware.send_parameter_change('filter_resonance', normalized_value)
    
    def _handle_eg_attack(self, event: SemanticEvent):
        """Handle EG attack change (CC 23 -> NTS-1 CC 16)."""
        if event.value is not None:
            self.state.set('eg_attack', event.value, source='midi')
            
            if self._external_hardware:
                normalized_value = event.value / 127.0
                self._external_hardware.send_parameter_change('eg_attack', normalized_value)
    
    def _handle_eg_release(self, event: SemanticEvent):
        """Handle EG release change (CC 24 -> NTS-1 CC 19)."""
        if event.value is not None:
            self.state.set('eg_release', event.value, source='midi')
            
            if self._external_hardware:
                normalized_value = event.value / 127.0
                self._external_hardware.send_parameter_change('eg_release', normalized_value)
    
    def _handle_delay_mix(self, event: SemanticEvent):
        """Handle delay mix change (CC 26 -> NTS-1 CC 33)."""
        if event.value is not None:
            self.state.set('delay_mix', event.value, source='midi')
            
            if self._external_hardware:
                normalized_value = event.value / 127.0
                self._external_hardware.send_parameter_change('delay_mix', normalized_value)
    
    def _handle_osc_a(self, event: SemanticEvent):
        """Handle OSC A parameter change (CC 50 -> NTS-1 CC 54)."""
        if event.value is not None:
            self.state.set('osc_a', event.value, source='midi')
            
            if self._external_hardware:
                normalized_value = event.value / 127.0
                self._external_hardware.send_parameter_change('osc_a', normalized_value)
    
    def _handle_osc_b(self, event: SemanticEvent):
        """Handle OSC B parameter change (CC 51 -> NTS-1 CC 55)."""
        if event.value is not None:
            self.state.set('osc_b', event.value, source='midi')
            
            if self._external_hardware:
                normalized_value = event.value / 127.0
                self._external_hardware.send_parameter_change('osc_b', normalized_value)
    
    def _handle_mod_a(self, event: SemanticEvent):
        """Handle MOD A parameter change (CC 52 -> NTS-1 CC 28)."""
        if event.value is not None:
            self.state.set('mod_a', event.value, source='midi')
            
            if self._external_hardware:
                normalized_value = event.value / 127.0
                self._external_hardware.send_parameter_change('mod_a', normalized_value)
    
    def _handle_mod_b(self, event: SemanticEvent):
        """Handle MOD B parameter change (CC 53 -> NTS-1 CC 29)."""
        if event.value is not None:
            self.state.set('mod_b', event.value, source='midi')
            
            if self._external_hardware:
                normalized_value = event.value / 127.0
                self._external_hardware.send_parameter_change('mod_b', normalized_value)
    
    def _handle_osc_type(self, event: SemanticEvent):
        """Handle OSC type change (CC 60 -> NTS-1 CC 53)."""
        if event.value is not None:
            self.state.set('osc_type', event.value, source='midi')
            
            if self._external_hardware:
                normalized_value = event.value / 127.0
                self._external_hardware.send_parameter_change('osc_type', normalized_value)
    
    def _handle_filter_type(self, event: SemanticEvent):
        """Handle filter type change (CC 61 -> NTS-1 CC 42)."""
        if event.value is not None:
            self.state.set('filter_type', event.value, source='midi')
            
            if self._external_hardware:
                normalized_value = event.value / 127.0
                self._external_hardware.send_parameter_change('filter_type', normalized_value)
    
    def _handle_mod_type(self, event: SemanticEvent):
        """Handle MOD type change (CC 62 -> NTS-1 CC 88)."""
        if event.value is not None:
            self.state.set('mod_type', event.value, source='midi')
            
            if self._external_hardware:
                normalized_value = event.value / 127.0
                self._external_hardware.send_parameter_change('mod_type', normalized_value)
    
    def _handle_reverb_mix(self, event: SemanticEvent):
        """Handle reverb mix change (CC 22)."""
        if event.value is not None:
            # Store in state for internal use
            self.state.set('reverb_mix', event.value, source='midi')
            
            # Phase 7: Send to external hardware via CC profile  
            if self._external_hardware:
                # Map CC value (0-127) to 0.0-1.0 for CC profile
                normalized_value = event.value / 127.0
                # Try reverb_depth as fallback parameter name
                success = self._external_hardware.send_parameter_change('reverb_mix', normalized_value)
                if not success:
                    self._external_hardware.send_parameter_change('reverb_depth', normalized_value)
    
    def _handle_swing(self, event: SemanticEvent):
        """Handle swing change (CC 23)."""
        if event.value is not None:
            # Map CC value (0-127) to swing range (0.0-0.5)
            swing = (event.value / 127.0) * 0.5
            self.state.set('swing', swing, source='midi')
    
    def _handle_density(self, event: SemanticEvent):
        """Handle density change (CC 24)."""
        if event.value is not None:
            # Map CC value (0-127) to density range (0.0-1.0)
            density = event.value / 127.0
            self.state.set('density', density, source='midi')
    
    def _handle_gate_length(self, event: SemanticEvent):
        """Handle gate length change."""
        if event.value is not None:
            # Map CC value (0-127) to gate length range (0.1-1.0)
            gate_length = 0.1 + (event.value / 127.0) * 0.9
            self.state.set('gate_length', gate_length, source='midi')
    
    def _handle_master_volume(self, event: SemanticEvent):
        """Handle master volume change (CC 25)."""
        if event.value is not None:
            self.state.set('master_volume', event.value, source='midi')
    
    def _handle_sequence_length(self, event: SemanticEvent):
        """Handle sequence length change (CC 50)."""
        if event.value is not None:
            # Map CC value (0-127) to sequence length (1-32)
            length = max(1, min(32, 1 + (event.value * 31) // 127))
            self.state.set('sequence_length', length, source='midi')
    
    def _handle_scale_select(self, event: SemanticEvent):
        """Handle scale selection (CC 51)."""
        if event.value is not None:
            # Map CC value to scale index - will be validated by state
            scale_index = event.value // 16  # 8 scales max (127/16 â‰ˆ 8)
            self.state.set('scale_index', scale_index, source='midi')
    
    def _handle_chaos_lock(self, event: SemanticEvent):
        """Handle chaos lock toggle (CC 52)."""
        if event.value is not None:
            # CC > 63 = lock on, <= 63 = lock off
            chaos_lock = event.value > 63
            self.state.set('chaos_lock', chaos_lock, source='midi')
    
    def _handle_reserved(self, event: SemanticEvent):
        """Handle reserved control (CC 53) - placeholder."""
        log.debug(f"reserved_control value={event.value}")
    
    def _handle_mode(self, event: SemanticEvent):
        """Handle mode change (CC 60)."""
        if event.value is not None:
            # Map CC value to mode index (0-7)
            mode = event.value // 16
            self.state.set('mode', mode, source='midi')
    
    def _handle_palette(self, event: SemanticEvent):
        """Handle palette change (CC 61)."""
        if event.value is not None:
            # Map CC value to palette index (0-7)
            palette = event.value // 16
            self.state.set('palette', palette, source='midi')
    
    def _handle_drift(self, event: SemanticEvent):
        """Handle drift change (CC 62)."""
        if event.value is not None:
            # Map CC value (0-127) to drift range (-0.2 to +0.2)
            drift = ((event.value - 63.5) / 63.5) * 0.2
            self.state.set('drift', drift, source='midi')
    
    def _handle_note_probability(self, event: SemanticEvent):
        """Handle note probability change."""
        if event.value is not None:
            # Map CC value (0-127) to probability (0.0-1.0)
            probability = event.value / 127.0
            self.state.set('note_probability', probability, source='midi')
