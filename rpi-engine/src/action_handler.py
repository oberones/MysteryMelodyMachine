"""Event handlers for semantic actions.

Translates semantic events from the router into state changes and sequencer operations.
Phase 2: Basic parameter mapping and step triggering.
"""

from __future__ import annotations
from typing import Dict, Callable, Optional
import logging
from state import State
from sequencer import Sequencer, NoteEvent
from events import SemanticEvent

log = logging.getLogger(__name__)


class ActionHandler:
    """Handles semantic actions by updating state and triggering sequencer operations."""
    
    def __init__(self, state: State, sequencer: Optional[Sequencer] = None):
        self.state = state
        self.sequencer = sequencer
        self._note_callback: Optional[Callable[[NoteEvent], None]] = None
        
        # Mapping from semantic action types to handler methods
        self._action_handlers: Dict[str, Callable[[SemanticEvent], None]] = {
            'trigger_step': self._handle_trigger_step,
            'tempo': self._handle_tempo,
            'filter_cutoff': self._handle_filter_cutoff,
            'reverb_mix': self._handle_reverb_mix,
            'swing': self._handle_swing,
            'density': self._handle_density,
            'note_probability': self._handle_note_probability,
            'master_volume': self._handle_master_volume,
            'sequence_length': self._handle_sequence_length,
            'scale_select': self._handle_scale_select,
            'chaos_lock': self._handle_chaos_lock,
            'reserved': self._handle_reserved,
            'mode': self._handle_mode,
            'palette': self._handle_palette,
            'drift': self._handle_drift,
        }
    
    def set_sequencer(self, sequencer: Sequencer):
        """Set the sequencer instance (for late binding)."""
        self.sequencer = sequencer
    
    def set_note_callback(self, callback: Callable[[NoteEvent], None]):
        """Set callback for note events generated by manual triggers."""
        self._note_callback = callback
    
    def handle_semantic_event(self, event: SemanticEvent):
        """Route a semantic event to the appropriate handler."""
        handler = self._action_handlers.get(event.type)
        if handler:
            try:
                handler(event)
                log.debug(f"action_handled type={event.type} value={event.value}")
            except Exception as e:
                log.error(f"Action handler error for {event.type}: {e}")
        else:
            log.warning(f"Unknown semantic action: {event.type}")
    
    def _handle_trigger_step(self, event: SemanticEvent):
        """Handle step trigger from button press.
        
        Phase 2: Manual step triggering - advance sequencer by one step.
        """
        if self.sequencer:
            # Force advance to next step
            current_step = self.state.get('step_position', 0)
            sequence_length = self.state.get('sequence_length', 8)
            next_step = (current_step + 1) % sequence_length
            self.state.set('step_position', next_step, source='manual_trigger')
            
            # Generate immediate note for manual trigger
            # Use note value from button press as basis
            if event.raw_note is not None and self._note_callback:
                # Simple mapping: use the button note directly with some velocity
                note = event.raw_note
                velocity = min(127, max(60, event.value or 80))
                
                note_event = NoteEvent(
                    note=note,
                    velocity=velocity,
                    timestamp=0.0,  # Will be set by callback handler
                    step=current_step
                )
                self._note_callback(note_event)
                log.info(f"manual_trigger step={current_step} note={note} velocity={velocity}")
    
    def _handle_tempo(self, event: SemanticEvent):
        """Handle tempo change (CC 20)."""
        if event.value is not None:
            # Map CC value (0-127) to BPM range (60-200)
            bpm = 60.0 + (event.value / 127.0) * 140.0
            self.state.set('bpm', bpm, source='midi')
    
    def _handle_filter_cutoff(self, event: SemanticEvent):
        """Handle filter cutoff change (CC 21)."""
        if event.value is not None:
            self.state.set('filter_cutoff', event.value, source='midi')
    
    def _handle_reverb_mix(self, event: SemanticEvent):
        """Handle reverb mix change (CC 22)."""
        if event.value is not None:
            self.state.set('reverb_mix', event.value, source='midi')
    
    def _handle_swing(self, event: SemanticEvent):
        """Handle swing change (CC 23)."""
        if event.value is not None:
            # Map CC value (0-127) to swing range (0.0-0.5)
            swing = (event.value / 127.0) * 0.5
            self.state.set('swing', swing, source='midi')
    
    def _handle_density(self, event: SemanticEvent):
        """Handle density change (CC 24)."""
        if event.value is not None:
            # Map CC value (0-127) to density range (0.0-1.0)
            density = event.value / 127.0
            self.state.set('density', density, source='midi')
    
    def _handle_master_volume(self, event: SemanticEvent):
        """Handle master volume change (CC 25)."""
        if event.value is not None:
            self.state.set('master_volume', event.value, source='midi')
    
    def _handle_sequence_length(self, event: SemanticEvent):
        """Handle sequence length change (CC 50)."""
        if event.value is not None:
            # Map CC value (0-127) to sequence length (1-32)
            length = max(1, min(32, 1 + (event.value * 31) // 127))
            self.state.set('sequence_length', length, source='midi')
    
    def _handle_scale_select(self, event: SemanticEvent):
        """Handle scale selection (CC 51)."""
        if event.value is not None:
            # Map CC value to scale index - will be validated by state
            scale_index = event.value // 16  # 8 scales max (127/16 â‰ˆ 8)
            self.state.set('scale_index', scale_index, source='midi')
    
    def _handle_chaos_lock(self, event: SemanticEvent):
        """Handle chaos lock toggle (CC 52)."""
        if event.value is not None:
            # CC > 63 = lock on, <= 63 = lock off
            chaos_lock = event.value > 63
            self.state.set('chaos_lock', chaos_lock, source='midi')
    
    def _handle_reserved(self, event: SemanticEvent):
        """Handle reserved control (CC 53) - placeholder."""
        log.debug(f"reserved_control value={event.value}")
    
    def _handle_mode(self, event: SemanticEvent):
        """Handle mode change (CC 60)."""
        if event.value is not None:
            # Map CC value to mode index (0-7)
            mode = event.value // 16
            self.state.set('mode', mode, source='midi')
    
    def _handle_palette(self, event: SemanticEvent):
        """Handle palette change (CC 61)."""
        if event.value is not None:
            # Map CC value to palette index (0-7)
            palette = event.value // 16
            self.state.set('palette', palette, source='midi')
    
    def _handle_drift(self, event: SemanticEvent):
        """Handle drift change (CC 62)."""
        if event.value is not None:
            # Map CC value (0-127) to drift range (-0.2 to +0.2)
            drift = ((event.value - 63.5) / 63.5) * 0.2
            self.state.set('drift', drift, source='midi')
    
    def _handle_note_probability(self, event: SemanticEvent):
        """Handle note probability change."""
        if event.value is not None:
            # Map CC value (0-127) to probability (0.0-1.0)
            probability = event.value / 127.0
            self.state.set('note_probability', probability, source='midi')
